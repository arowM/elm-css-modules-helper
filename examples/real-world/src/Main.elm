module Main exposing (main)

{-| This sample app shows how to use CSS modules in Elm without hack.
By using `elm-html-with-context` library, it can be much easier to use CSS modules with the manner of atomic design.
-}

import Browser
import CssClass exposing (CssClass, class)
import Html exposing (Attribute, Html)
import Html.Attributes as Attributes
import Html.Events as Events
import Json.Decode as Decode exposing (Decoder, Value)
import WithContext exposing (WithContext)
import WithContext.Lazy as WithContext



-- APP


main : Program Value Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }



-- Model


type alias Model =
    { style : Style
    , inputBox1 : Maybe String
    , inputBox2 : Maybe String
    }


{-| This type represents dictionaries for CSS class names generated by CSS modules.
-}
type alias Style =
    { layout : CssClass
    , label : CssClass
    , input : CssClass
    , app : CssClass
    }


{-| Decoder for `Style`.
Input JSON would be following format.

```json
{ "layout": {
    "wrap": "layout__wrap--22P2G",
    "pack": "layout__pack--2OmbP",
    ...
  },
  "input": {
    ...
  },
  ...
}
```

-}
decoder : Decoder Style
decoder =
    Decode.map4 Style
        (Decode.field "layout" CssClass.decode)
        (Decode.field "label" CssClass.decode)
        (Decode.field "input" CssClass.decode)
        (Decode.field "app" CssClass.decode)


init : Value -> ( Model, Cmd Msg )
init v =
    ( { style =
            Decode.decodeValue decoder v
                |> Result.toMaybe
                |> Maybe.withDefault
                    -- `CssClass.empty` is used when failing to parse flags.
                    { layout = CssClass.empty
                    , label = CssClass.empty
                    , input = CssClass.empty
                    , app = CssClass.empty
                    }
      , inputBox1 = Nothing
      , inputBox2 = Nothing
      }
    , Cmd.none
    )



-- Update


type Msg
    = OnInputInputBox1 String
    | OnInputInputBox2 String


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        OnInputInputBox1 str ->
            ( { model
                | inputBox1 = Just str
              }
            , Cmd.none
            )

        OnInputInputBox2 str ->
            ( { model
                | inputBox2 = Just str
              }
            , Cmd.none
            )



-- View


{-| First, let's declare our custom `Html_ msg`.
The `Context` is implicitly passed to each view functions.
-}
type alias Html_ msg =
    WithContext Context msg


{-| Data type actually passed to each view functions.
Even if there are one data type in context, it is recommended to put in record as this `Context` type.
If we declare `Context` as `type alias Context = Style`, it requires developers to change all the functions it uses `Style` value.
By wrapping in record, it makes easy to add other context later.
-}
type alias Context =
    { style : Style
    }


toContext : Model -> Context
toContext model =
    { style = model.style
    }


view : Model -> Html Msg
view model =
    -- Convert to normal `Html` on root view function by passing context.
    WithContext.toHtml (toContext model) <|
        -- This generates `Html_ Msg`.
        wrap
            [ inputRow "item 1" OnInputInputBox1 model.inputBox1
            , inputRow "item 2" OnInputInputBox2 model.inputBox2
            ]



-- Molecular view


inputRow : String -> (String -> Msg) -> Maybe String -> Html_ Msg
inputRow name onInput val =
    wrap
        [ WithContext.node
            -- Any view functions have context implicitly, so they can use context any time like this.
            (\{ style } ->
                Html.div
                    -- This `class` function is exposed by `CssClass` module.
                    -- It actually generates something like:
                    -- `Html.Attributes.class "app__inputRow--aAOLM"`
                    [ class style.app "inputRow"
                    , class style.layout "row"
                    , class style.layout "alignCenter"
                    ]
            )
            [ label name
            , expanded
                [ input onInput val
                ]
            ]
        ]



-- Atomic views


label : String -> Html_ Msg
label str =
    wrap
        -- It is needed to `lift` context before using `lazy` to actually optimize the behaviour.
        [ WithContext.lift .style <|
            -- By using `lazy`, `label_` view function is not actually called if `str` is not changed on each updates.
            WithContext.lazy label_ str
        ]


label_ : Style -> String -> Html Msg
label_ style str =
    -- Make sure that this debug message is only shown at page load.
    -- It is because `WithContext.lazy` works.
    Debug.log "label_ was rerendered" <|
        Html.div
            [ class style.label "default"
            ]
            [ Html.text str
            ]


input : (String -> Msg) -> Maybe String -> Html_ Msg
input onInput val =
    wrap
        [ WithContext.lift .style <|
            WithContext.lazy2 input_ onInput val
        ]


input_ : Style -> (String -> Msg) -> Maybe String -> Html Msg
input_ style onInput val =
    -- Make sure that this debug message is only shown at page load and when user inputs.
    -- It is because `WithContext.lazy` works.
    Debug.log "input_ was rerendered" <|
        Html.input
            [ class style.input "default"
            , Attributes.type_ "text"
            , Attributes.value <| Maybe.withDefault "" val
            , Events.onInput onInput
            ]
            []



-- Layout functions


layout : String -> List (Html_ Msg) -> Html_ Msg
layout key =
    WithContext.node <|
        \{ style } ->
            Html.div
                [ class style.layout key
                ]


wrap : List (Html_ Msg) -> Html_ Msg
wrap =
    layout "wrap"


expanded : List (Html_ Msg) -> Html_ Msg
expanded =
    layout "expanded"



-- Subscription


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none
